#!/usr/bin/env python3

import pandas as pd

import sys
import os
import argparse
import h5py
from pytpc.fitting import MCFitter, Annealer, BadEventError
from pytpc.utilities import find_run_number
from pytpc.cleaning import apply_clean_cut
import yaml
import logging
import logging.config

from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, Float, create_engine
from sqlalchemy.sql import func
from contextlib import contextmanager

logger = logging.getLogger(__name__)


# Database setup

SQLBase = declarative_base()
Session = sessionmaker()


@contextmanager
def managed_session():
    session = Session()
    try:
        yield session
        session.commit()
    except:
        session.rollback()
        raise
    finally:
        session.close()


class MinimizerResult(SQLBase):
    __tablename__ = 'mcmin_results'
    evt_id = Column(Integer, primary_key=True)
    x0 = Column(Float)
    y0 = Column(Float)
    z0 = Column(Float)
    enu0 = Column(Float)
    azi0 = Column(Float)
    pol0 = Column(Float)
    posChi2 = Column(Float)
    enChi2 = Column(Float)
    vertChi2 = Column(Float)
    lin_scat_ang = Column(Float)
    lin_beam_int = Column(Float)
    lin_chi2 = Column(Float)
    rad_curv = Column(Float)
    brho = Column(Float)
    curv_en = Column(Float)
    curv_ctr_x = Column(Float)
    curv_ctr_y = Column(Float)


def find_last_completed_event():
    with managed_session() as session:
        query = session.query(func.max(MinimizerResult.evt_id).label('last_evtid'))
        res = query.one()
        last_evtid = res.last_evtid
        if last_evtid is None:
            return 0
        else:
            return last_evtid


def create_and_setup_database_engine(path):
    engine = create_engine('sqlite:///{}'.format(path))
    SQLBase.metadata.create_all(bind=engine)
    Session.configure(bind=engine)
    return engine


@contextmanager
def monitored_execution(procedure_name, evt_id):
    try:
        yield
    except BadEventError:
        raise
    except Exception as err:
        raise RuntimeError('{:s} failed for event {:d}'.format(procedure_name, evt_id)) from err


class FitManager(object):
    def __init__(self, config, fitter_class, evtlist_path, input_path, output_path):
        self.fitter = fitter_class(config)
        self.run_num = find_run_number(input_path)
        self.input_file = h5py.File(input_path, 'r')
        self.db_engine = create_and_setup_database_engine(output_path)

        good_evts = pd.read_hdf(evtlist_path, 'evt_list')
        run_mask = good_evts.run_num == self.run_num
        nevts = len(good_evts[run_mask])
        logger.info('Loaded VME results. VME had %d valid events in this run.', nevts)

        last_evtid = find_last_completed_event()
        if last_evtid > 0:
            logger.info('Already finished up to event %d. Starting from where we left off.', last_evtid)
        evtid_mask = good_evts.evt_id > last_evtid

        self.evt_ids_to_process = good_evts[run_mask & evtid_mask].evt_id.values

    def evtid_iterator(self):
        nevts = len(self.evt_ids_to_process)
        for i, evt_id in enumerate(self.evt_ids_to_process):
            if i % 100 == 0:
                logger.info('Finished %d / %d events', i, nevts)
            yield int(evt_id)

    def read_data(self, evt_id):
        dataset = self.input_file['/clean/{}'.format(evt_id)]
        data = dataset[:]
        cx, cy = dataset.attrs['center'][:2]
        return data, (cx, cy)

    def clean_data(self, data):
        cleaned = apply_clean_cut(data)
        if len(cleaned) < 50:
            raise BadEventError('Too few points after cleaning')
        else:
            return cleaned

    def process_event(self, evt_id):
        with monitored_execution('Reading', evt_id):
            raw_xyz, (cx, cy) = self.read_data(evt_id)

        with monitored_execution('Cleaning', evt_id):
            clean_xyz = self.clean_data(raw_xyz)

        with monitored_execution('Fitting', evt_id):
            fitres = self.fitter.process_event(clean_xyz, cx, cy, preprocess_kwargs={'rotate_pads': False})

        with managed_session() as session:
            dbfitres = MinimizerResult(evt_id=evt_id, **fitres)
            session.add(dbfitres)


def parse_args():
    parser = argparse.ArgumentParser(description='Fit data using Monte Carlo optimization')
    parser.add_argument('--config', '-c', help='Path to config file, in YAML format', required=True)
    parser.add_argument('--config-patch', '-p', help='Configuration patches', action='append')
    parser.add_argument('--evtlist', '-e', help='Path to HDF5 file with results from the circle fit', required=True)
    parser.add_argument('--algorithm', '-a', help='Algorithm to use', type=str,
                        choices=['mc', 'annealer'], default='mc')
    parser.add_argument('--verbose', '-v', action='count', default=0,
                        help='Print more information')
    parser.add_argument('input_file', help='The input HDF5 file containing the peaks')
    parser.add_argument('db_path', help='Path to the output database file')
    args = parser.parse_args()

    if args.verbose >= 1:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    return args


def setup_logging(config):
    try:
        log_conf = config['logging_config']
        logging.config.dictConfig(log_conf)
    except KeyError:
        logger.warning('No logging config found. Info messages may be suppressed.')


def main():
    args = parse_args()

    with open(os.path.abspath(args.config)) as f:
        config = yaml.load(f)

    setup_logging(config)

    if args.config_patch is not None:
        for path in args.config_patch:
            full_path = os.path.abspath(path)
            with open(full_path, 'r') as f:
                patch = yaml.load(f)
            config.update(patch)
            logger.info('Patched config with %s', os.path.basename(path))

    algo_dict = {'mc': MCFitter,
                 'annealer': Annealer}

    fitter_class = algo_dict[args.algorithm]

    fit_manager = FitManager(
        config=config,
        fitter_class=fitter_class,
        evtlist_path=args.evtlist,
        input_path=args.input_file,
        output_path=args.db_path,
    )

    for evt_id in fit_manager.evtid_iterator():
        try:
            fit_manager.process_event(evt_id)
        except BadEventError as err:
            logger.warning('Event %d was bad: %s', evt_id, err)
        except Exception:
            logger.exception('Event %d failed', evt_id)


if __name__ == '__main__':
    import signal

    def handle_signal(signum, stack_frame):
        logger.critical('Received signal %d. Quitting.', signum)
        sys.stdout.flush()
        sys.exit(1)

    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGQUIT, handle_signal)

    main()
