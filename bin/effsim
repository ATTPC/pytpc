#!/usr/local/env python3
from pytpc.gases import InterpolatedGas
from pytpc.utilities import read_lookup_table, find_exclusion_region
from effsim import EfficiencySimulator, param_generator, count_finished_events, initialize_database
import yaml
import argparse
import os
from sqlalchemy import create_engine
import logging
import logging.config


logger = logging.getLogger(__name__)


def parse_arguments():
    parser = argparse.ArgumentParser(description='A program to check the efficiency of the linear and MC fits')
    parser.add_argument('--num_pts', '-n', help='Number of points to simulate. If uniform dist, num per dimension', type=int)
    parser.add_argument('--xcfg-path', '-x', help='Path to GET config file, for exlusion region')
    parser.add_argument('--evtgen-config-patch', '-e', help='A special patch for the evtgen config')
    parser.add_argument('--config-patch', '-p', help='One or more YAML files to patch the config with', action='append')
    parser.add_argument('config', help='Path to config file')
    parser.add_argument('output', help='Path to output database')
    return parser.parse_args()


def setup_logging(config):
    try:
        log_conf = config['logging_config']
        logging.config.dictConfig(log_conf)
    except KeyError:
        logger.warning('No logging config found. Info messages may be suppressed.')


def load_config_file(path, patches=None, evtgen_patch=None):
    with open(path, 'r') as f:
        config = yaml.load(f)

    setup_logging(config)

    logger.info('Read config file %s', os.path.basename(path))

    if config['micromegas_tb'] != 0:
        logger.warning('Micromegas TB was nonzero in config. Setting value to zero.')
        config['micromegas_tb'] = 0

    if patches is not None:
        for patch_path in patches:
            with open(patch_path, 'r') as f:
                patch = yaml.load(f)
            config.update(patch)
            logger.info('Applied config patch %s', os.path.basename(patch_path))

    evtgen_config = config.copy()

    if evtgen_patch is not None:
        with open(evtgen_patch, 'r') as f:
            evtgen_config_patch = yaml.load(f)
        evtgen_config.update(evtgen_config_patch)
        logger.info('Patched config for event generator using %s', os.path.basename(evtgen_patch))

    return config, evtgen_config


def main():
    args = parse_arguments()

    config, evtgen_config = load_config_file(args.config, args.config_patch, args.evtgen_config_patch)

    gas = InterpolatedGas(config['gas_name'], config['gas_pressure'])

    num_pts = args.num_pts or config['dist_num_pts']

    if args.xcfg_path is not None:
        logger.info('Reading exclusion regions from %s', os.path.basename(args.xcfg_path))
        lookup = read_lookup_table(config['padmap_path'])
        excluded_pads, lowgain_pads = find_exclusion_region(args.xcfg_path, lookup)
    else:
        excluded_pads = []
        lowgain_pads = []

    effsim = EfficiencySimulator(config, excluded_pads=excluded_pads, lowgain_pads=lowgain_pads,
                                 evtgen_config=evtgen_config)

    sql_engine = create_engine('sqlite:///{}'.format(args.output))
    initialize_database(sql_engine)

    num_finished = count_finished_events()
    if num_finished >= num_pts:
        logger.info('Already finished all requested events.')
        return
    elif num_finished > 0:
        logger.info('Already finished %d events. Resuming from where we left off.', num_finished)
        num_pts -= num_finished

    params = param_generator(
        beam_enu0=evtgen_config['beam_enu0'],
        beam_mass=evtgen_config['beam_mass'],
        beam_chg=evtgen_config['beam_charge'],
        proj_mass=evtgen_config['mass_num'],
        proj_chg=evtgen_config['charge_num'],
        gas=gas,
        num_evts=num_pts
    )

    for evt_id, param_vector in enumerate(params):
        evt_id += num_finished

        if evt_id % 100 == 0:
            logger.info('Progress: at event %d / %d', evt_id, num_pts)

        try:
            effsim.process_event(evt_id, param_vector)
        except Exception:
            logger.exception('Event %d failed', evt_id)


if __name__ == '__main__':
    import signal
    import sys

    def handle_signal(signum, stack_frame):
        logger.critical('Received signal %d. Quitting.', signum)
        sys.stdout.flush()
        sys.exit(1)

    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGQUIT, handle_signal)

    main()
