#!/usr/local/env python3
import numpy as np
import pandas as pd
import pytpc
from pytpc.gases import InterpolatedGas
from pytpc.constants import pi, degrees, p_mc2
from pytpc.utilities import find_vertex_energy, Base
from pytpc.fitting import MCFitter
from pytpc.fitting.mixins import TrackerMixin, EventGeneratorMixin
from pytpc.simulation import find_proton_params
import yaml
import argparse
import h5py
import os

import logging
logger = logging.getLogger(__name__)


def three_point_center(p1, p2, p3):
    mp1 = (p1 + p2) / 2
    mp2 = (p2 + p3) / 2
    sl1 = (p1[0] - p2[0]) / (p2[1] - p1[1])
    sl2 = (p2[0] - p3[0]) / (p3[1] - p2[1])
    xc = (sl1 * mp1[0] - sl2 * mp2[0] - mp1[1] + mp2[1]) / (sl1 - sl2)
    yc = (-sl2 * mp1[1] + sl1 * (sl2 * (mp1[0] - mp2[0]) + mp2[1])) / (sl1 - sl2)
    return xc, yc


def make_params(beam_enu0, beam_mass, beam_chg, proj_mass, proj_chg, gas, num_evts):
    params = pd.DataFrame(0, columns=('evt_id', 'x0', 'y0', 'z0', 'enu0', 'azi0', 'pol0'), index=range(num_evts))
    params.x0 = np.random.normal(0, 0.010, size=num_evts)
    params.y0 = np.random.normal(0, 0.010, size=num_evts)
    params.z0 = np.random.uniform(0, 1, size=num_evts)
    params.azi0 = np.random.uniform(0, 2*pi, size=num_evts)
    params.pol0 = np.random.uniform(pi/2, pi - 10*degrees, size=num_evts)
    params.evt_id = np.arange(num_evts)

    vert_ens = find_vertex_energy(params.z0, beam_enu0, beam_mass, beam_chg, gas)  # the total kinetic energies
    vert_ens[np.where(vert_ens > beam_enu0 * beam_mass)] = 0.0
    params.enu0 = find_proton_params(pi - params.pol0, beam_mass*p_mc2, proj_mass*p_mc2,
                                     proj_mass*p_mc2, beam_mass*p_mc2, vert_ens)[1] - proj_mass*p_mc2

    while np.any(params.enu0 < 1.0):
        params = params[params.enu0 >= 1.0].copy()
        num_good = len(params)
        params.index = range(num_good)
        params.evt_id = range(num_good)
        replacements = make_params(beam_enu0, beam_mass, beam_chg, proj_mass, proj_chg, gas, num_evts - num_good)
        replacements.index = range(num_good, num_evts)
        replacements.evt_id = range(num_good, num_evts)
        params = pd.concat((params, replacements), axis=0)

    return params


def make_params_uniform(beam_enu0, beam_mass, beam_chg, proj_mass, proj_chg, gas, num_evts):
    params = pd.DataFrame(0, columns=('evt_id', 'x0', 'y0', 'z0', 'enu0', 'azi0', 'pol0'), index=range(num_evts**2))
    stop_dist = gas.range(beam_enu0*beam_mass, beam_mass, beam_chg)
    zs = np.linspace(max(1.0 - stop_dist, 0.0), 1, num_evts)
    pols = np.linspace(pi/2 + 5*degrees, pi - 10*degrees, num_evts)
    params.z0 = np.repeat(zs, num_evts)
    params.pol0 = np.tile(pols, num_evts)

    params.evt_id = np.arange(num_evts**2)
    params.azi0 = 180.*degrees

    vert_ens = find_vertex_energy(params.z0, beam_enu0, beam_mass, beam_chg, gas)  # the total kinetic energies
    vert_ens[np.where(vert_ens > beam_enu0 * beam_mass)] = 0.0
    params.enu0 = find_proton_params(pi - params.pol0, beam_mass*p_mc2, proj_mass*p_mc2,
                                     proj_mass*p_mc2, beam_mass*p_mc2, vert_ens)[1] - proj_mass*p_mc2

    return params


class EventGenerator(object):
    def __init__(self, config, badpads=None):
        self.tilt = config['tilt'] * degrees
        self.untiltmat = pytpc.utilities.tilt_matrix(self.tilt)
        self.efield = np.array(config['efield'])
        self.bfield = np.array(config['bfield'])
        self.vd = np.array(config['vd'])  # must remain in detector frame since it is used after un-tilting
        self.clock = config['clock']
        self.gas = InterpolatedGas(config['gas_name'], config['gas_pressure'])
        self.mass_num = config['mass_num']
        self.charge_num = config['charge_num']
        self.beam_enu0 = config['beam_enu0']
        self.beam_mass = config['beam_mass']
        self.beam_charge = config['beam_charge']
        self.pad_rot_angle = config['pad_rot_angle'] * degrees
        self.ioniz = config['ioniz']
        self.gain = config['micromegas_gain']
        self.shape = float(config['shape'])
        self.badpads = badpads
        self.diff_sigma = config['evtgen_diffusion_sigma']

        self.tracker = atmc.Tracker(mass_num=self.mass_num,
                                    charge_num=self.charge_num,
                                    beam_enu0=self.beam_enu0,
                                    beam_mass=self.beam_mass,
                                    beam_charge=self.beam_charge,
                                    gas=self.gas,
                                    efield=self.efield,
                                    bfield=self.bfield,
                                    max_en=1000)

        with h5py.File(config['lut_path'], 'r') as hf:
            lut = hf['LUT'][:]
        self.padplane = atmc.PadPlane(lut, -0.280, 0.0001, -0.280, 0.0001, self.pad_rot_angle)
        self.evtgen = atmc.EventGenerator(self.padplane, self.vd, self.clock, self.shape, self.mass_num,
                                          self.ioniz, self.gain, self.tilt, self.diff_sigma)

    def make_event(self, x0, y0, z0, enu0, azi0, pol0):
        tr = self.tracker.track_particle(x0, y0, z0, enu0, azi0, pol0)
        tr = tr[np.where(np.logical_and(tr[:, 2] > 0, tr[:, 2] < 1))].copy()
        pos = tr[:, :3]
        en = tr[:, 4]

        cx, cy = three_point_center(tr[0, :2], tr[1, :2], tr[2, :2])
        center = np.array([cx, cy, 0]) * 1000
        center = self.untiltmat @ center
        center[1] -= np.tan(self.tilt) * 1000
        center = pytpc.evtdata.uncalibrate(center.reshape((-1, 3)), self.vd, self.clock).ravel()

        peaks = self.evtgen.make_peaks(pos, en)

        hit_pattern = self.evtgen.make_hit_pattern(pos, en)

        return peaks, center[:2], hit_pattern

    def drop_excluded_pads(self, xyz=None, hit_pattern=None):
        # Assume that the last column of xyz represents the pad number
        xyz = xyz[np.where(~np.in1d(xyz[:, -1], self.badpads))]
        hit_pattern[self.badpads] = 0

        return xyz, hit_pattern


def main():
    parser = argparse.ArgumentParser(description='A program to check the efficiency of the linear and MC fits')
    parser.add_argument('--num_pts', '-n', help='Number of points to simulate. If uniform dist, num per dimension', type=int)
    parser.add_argument('--uniform', '-u', help='Use uniform distribution', action='store_true', default=False)
    parser.add_argument('--algorithm', '-a', help='Algorithm to use', type=str, choices=['mc', 'simplex', 'compass'], default='mc')
    parser.add_argument('--drop_pads', '-d', help='Path to list of pads to drop. Plain text with newline separators')
    parser.add_argument('--evtgen-config-patch', '-e', help='A special patch for the evtgen config')
    parser.add_argument('--config-patch', '-p', help='One or more YAML files to patch the config with', action='append')
    parser.add_argument('config', help='Path to config file')
    parser.add_argument('output', help='Path to output database')
    args = parser.parse_args()

    with open(args.config, 'r') as f:
        config = yaml.load(f)
    logger.info('Read config file %s', os.path.basename(args.config))

    if config['micromegas_tb'] != 0:
        logger.warning('Micromegas TB was nonzero in config. Setting value to zero.')
        config['micromegas_tb'] = 0

    if args.config_patch is not None:
        for patch_path in args.config_patch:
            with open(patch_path, 'r') as f:
                patch = yaml.load(f)
            config.update(patch)
            logger.info('Applied config patch %s', os.path.basename(patch_path))

    evtgen_config = config.copy()

    if args.evtgen_config_patch is not None:
        with open(args.evtgen_config_patch, 'r') as f:
            evtgen_config_patch = yaml.load(f)
        evtgen_config.update(evtgen_config_patch)
        logger.info('Patched config for event generator using %s', os.path.basename(args.evtgen_config_patch))

    gas = InterpolatedGas(config['gas_name'], config['gas_pressure'])

    num_pts = args.num_pts or config['dist_num_pts']

    if args.drop_pads is not None:
        logger.info('Reading dropped pads list from %s', os.path.basename(args.drop_pads))
        badpads = np.fromfile(args.drop_pads, sep='\n', dtype='int64')
    else:
        badpads = None

    if args.uniform:
        params = make_params_uniform(config['beam_enu0'], config['beam_mass'], config['beam_charge'],
                                     config['mass_num'], config['charge_num'], gas, num_pts)
    else:
        params = make_params(config['beam_enu0'], config['beam_mass'], config['beam_charge'],
                             config['mass_num'], config['charge_num'], gas, num_pts)

    evtgen = EventGenerator(evtgen_config, badpads=badpads)

    algo_dict = {'mc': mcmin.MCFitter,
                 'simplex': simplex.SimplexFitter,
                 'compass': compass.CompassFitter}

    fitter_class = algo_dict[args.algorithm]
    fitter = fitter_class(config)

    logger.info('Using fitter %s', args.algorithm)

    writer = Writer(args.output)
    params_table_name = 'params'
    params_table_cols = [['evt_id', 'INTEGER UNIQUE'],
                         ['x0', 'REAL'],
                         ['y0', 'REAL'],
                         ['z0', 'REAL'],
                         ['enu0', 'REAL'],
                         ['azi0', 'REAL'],
                         ['pol0', 'REAL']]
    writer.create_table(params_table_name, params_table_cols)

    mcmin_table_name = 'fit_res'
    mcmin_table_cols = [['evt_id', 'INTEGER PRIMARY KEY']] + fitter_class.output_columns
    mcmin_table_cols.append(['num_pts', 'INTEGER'])

    writer.create_table(mcmin_table_name, mcmin_table_cols)

    for i, p in params.iterrows():
        writer.write(params_table_name, p)
        if i % 100 == 0:
            logger.info('Progress: at event %d / %d', i, len(params))

        if p.enu0 < 1.0:
            continue

        try:
            raw_xyz, (cx, cy), exp_hits = evtgen.make_event(p.x0, p.y0, p.z0, p.enu0, p.azi0, p.pol0)
            if badpads is not None:
                raw_xyz, exp_hits = evtgen.drop_excluded_pads(raw_xyz, exp_hits)
        except Exception:
            logger.exception('Evt %d: Track simulation failed', i)
            continue

        if len(raw_xyz) == 0:
            logger.warn('Evt %d: Result was zero-length', i)
            continue

        try:
            res = fitter.process_event(raw_xyz, cx, cy, remove_noise=False)
            res['evt_id'] = int(i)
            res['num_pts'] = int(raw_xyz.shape[0])
        except mcmin.BadEventError as e:
            logger.warning('Event %d: Bad event (%s)', i, e)
        except Exception:
            logger.exception('Evt %d: Fit failure', i)
        else:
            writer.write(mcmin_table_name, res)


if __name__ == '__main__':
    import signal
    import sys

    def handle_signal(signum, stack_frame):
        logger.critical('Received signal %d. Quitting.', signum)
        sys.stdout.flush()
        sys.exit(1)

    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGQUIT, handle_signal)

    main()
