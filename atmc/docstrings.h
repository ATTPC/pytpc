const char* MCTracker_doc =
    "Tracker(mass_num, charge_num, eloss, efield, bfield)\n"
    "\n"
    "A class for simulating the track of a charged particle in the AT-TPC.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "massNum, chargeNum : int\n"
    "    The mass and charge numbers of the projectile.\n"
    "eloss : ndarray\n"
    "    The energy loss for the particle, in MeV/m, as a function of projectile energy.\n"
    "    This should be indexed in 1-keV steps.\n"
    "efield, bfield : array-like\n"
    "    The electric and magnetic fields, in SI units.\n"
    "\n"
    "Raises\n"
    "------\n"
    "ValueError\n"
    "    If the dimensions of an input array were invalid.\n";

const char* MCTracker_trackParticle_doc =
    "Tracker.track_particle(x0, y0, z0, enu0, azi0, pol0)\n"
    "\n"
    "Simulate the trajectory of a particle.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x0, y0, z0, enu0, azi0, pol0 : float\n"
    "    The initial position (m), energy per nucleon (MeV/u), and azimuthal and polar angles (rad).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ndarray\n"
    "    The simulated track. The columns are x, y, z, time, energy/nucleon, azimuthal angle, polar angle.\n"
    "    The positions are in meters, the time is in seconds, and the energy is in MeV/u.\n"
    "\n"
    "Raises\n"
    "------\n"
    "RuntimeError\n"
    "    If tracking fails for some reason.\n";

const char* MCMCminimizer_doc =
    "Minimizer(mass_num, charge_num, eloss, efield, bfield)\n"
    "\n"
    "A Monte Carlo minimizer for particle tracks."
    "\n"
    "Parameters\n"
    "----------\n"
    "massNum, chargeNum : int\n"
    "    The mass and charge number of the projectile.\n"
    "eloss : ndarray\n"
    "    The energy loss for the particle, in MeV/m, as a function of projectile energy.\n"
    "    This should be indexed in 1-keV steps.\n"
    "efield, bfield : ndarray\n"
    "    The electric and magnetic field vectors, in SI units.\n"
    "\n"
    "Raises\n"
    "------\n"
    "ValueError\n"
    "    If a provided array has invalid dimensions.\n";


const char* MCMCminimizer_minimize_doc =
    "Minimizer.minimize(ctr0, sig0, true_values, num_iters=10, num_pts=200, redFactor=0.8, details=False)\n"
    "\n"
    "Perform chi^2 minimization for the track.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "ctr0 : ndarray\n"
    "    The initial guess for the track's parameters. These are (x0, y0, z0, enu0, azi0, pol0, bmag0).\n"
    "sig0 : ndarray\n"
    "    The initial width of the parameter space in each dimension. The distribution will be centered on `ctr0` with a\n"
    "    width of `sig0 / 2` in each direction.\n"
    "trueValues : ndarray\n"
    "    The experimental data points, as (x, y, z) triples.\n"
    "numIters : int\n"
    "    The number of iterations to perform before stopping. Each iteration draws `numPts` samples and picks the best one.\n"
    "numPts : int\n"
    "    The number of samples to draw in each iteration. The tracking function will be evaluated `numPts * numIters` times.\n"
    "redFactor : float\n"
    "    The factor to multiply the width of the parameter space by on each iteration. Should be <= 1.\n"
    "details : bool\n"
    "    Controls the amount of detail returned. If true, return the things listed below. If False, return just\n"
    "    the center and the last chi^2 value.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ctr : ndarray\n"
    "    The fitted track parameters.\n"
    "minChis : ndarray\n"
    "    The minimum chi^2 value at the end of each iteration.\n"
    "allParams : ndarray\n"
    "    The parameters from all generated tracks. There will be `numIters * numPts` rows.\n"
    "goodParamIdx : ndarray\n"
    "    The row numbers in `allParams` corresponding to the best points from each iteration, i.e. the ones whose\n"
    "    chi^2 values are in `minChis`.\n"
    "\n"
    "Raises\n"
    "------\n"
    "RuntimeError\n"
    "    If tracking fails for some reason.\n";

const char* MCMCminimizer_findEnergyDeviation_doc =
    "Minimizer.find_energy_deviation(sim_pos, sim_en, exp_mesh)\n"
    "\n"
    "Find the deviations between the simulated track's energy and the experimental data.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "sim_pos : ndarray\n"
    "    The simulated track's (x, y, z) positions. The units should be compatible with the\n"
    "    units of the pad plane object (probably meters).\n"
    "sim_en : ndarray\n"
    "    The simulated track's energy values, in MeV/u. This should have the same number of rows\n"
    "    as sim_pos.\n"
    "exp_mesh : ndarray\n"
    "    The simulated track's reconstructed mesh signal. This should have a length of 512 like\n"
    "    the GET electronics signals.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ndarray\n"
    "    The deviation between the two signals, as seen by the minimizer.\n";

const char* MCPadPlane_doc =
    "PadPlane(lookup_table, x_lower_bound, x_delta, y_lower_bound, y_delta, rot_angle=0)\n"
    "\n"
    "A lookup table for finding the number of the pad under a certain (x, y) position.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "lookup_table : ndarray\n"
    "    An array of pad number as a function of x (columns) and y (rows).\n"
    "x_lower_bound : float\n"
    "    The x value of the first column of the lookup table.\n"
    "x_delta : float\n"
    "    The x step between adjacent columns.\n"
    "y_lower_bound : float\n"
    "    The y value of the first row of the lookup table.\n"
    "y_delta : float\n"
    "    The y step between adjacent rows.\n"
    "rot_angle : float, optional\n"
    "    An angle, in radians, through which to rotate the pad plane.\n";

const char* MCPadPlane_getPadNumberFromCoordinates_doc =
    "PadPlane.get_pad_number_from_coordinates(x, y)\n"
    "\n"
    "Look up the pad number under the given point.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y : float\n"
    "    The x and y position to look up.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "int\n"
    "    The pad number under the given point. This will be whatever value is in the lookup table at that position.\n"
    "    If the lookup table contains invalid values (e.g. to represent areas that do not contain a pad), then\n"
    "    the result should be compared to the invalid value to check that it is a valid pad number.\n"
    "\n"
    "Raises\n"
    "------\n"
    "RuntimeError\n"
    "    If the point was outside the dimension of the lookup table, or if anything else failed.\n";

const char* MCEventGenerator_doc =
    "EventGenerator(pad_plane, vd, clock, shape, mass_num, ioniz, gain)\n"
    "\n"
    "A GET event generator. This can be used to generate events from simulated tracks.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "pad_plane : PadPlane instance\n"
    "    The pad lookup table to use when projecting to the Micromegas. The units should be meters.\n"
    "vd : array-like\n"
    "    The drift velocity vector, in cm/us.\n"
    "clock : float\n"
    "    The write clock, in Hz.\n"
    "shape : float\n"
    "    The shaping time, in seconds.\n"
    "mass_num : int\n"
    "    The particle's mass number.\n"
    "ioniz : float\n"
    "    The mean ionization potential of the gas, in eV.\n"
    "gain : int\n"
    "    The gain to apply to the event.\n";

const char* MCEventGenerator_makeEvent_doc =
    "EventGenerator.make_event(track)\n"
    "\n"
    "Make the electronics signals from the given track matrix.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "track : ndarray\n"
    "    An array representing a simulated track, such as that produced by the `Tracker` class. The\n"
    "    columns should be x(m), y(m), z(m), time(s), enu(MeV/u), azi(rad), pol(rad).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "dict\n"
    "    A dict mapping the pad number (as int) to a generated signal (as an ndarray).\n"
    "\n"
    "Raises\n"
    "------\n"
    "RuntimeError\n"
    "    If the process fails for some reason.\n";

const char* MCEventGenerator_makeMeshSignal_doc =
    "EventGenerator.make_mesh_signal(pos, en)\n"
    "\n"
    "Make the simulated mesh signal, or the total across time buckets of the simulated signals.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "pos : ndarray\n"
    "    The simulated track positions, as (x, y, z) triples. The units should be compatible with the\n"
    "    pad plane's units (probably meters).\n"
    "en : ndarray\n"
    "    The energy of the simulated particle at each time step, in MeV/u.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ndarray\n"
    "    The simulated mesh signal. The shape is (512,).\n";

const char* mcopt_wrapper_find_deviations_docstring =
    "Find the deviations. These can be summed to find chi^2.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "simArr : ndarray\n"
    "    The simulated track.\n"
    "expArr : ndarray\n"
    "    The experimental data.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "devArr : ndarray\n"
    "    The array of differences (or deviations).\n";
